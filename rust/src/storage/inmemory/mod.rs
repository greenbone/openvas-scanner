// SPDX-FileCopyrightText: 2025 Greenbone AG
//
// SPDX-License-Identifier: GPL-2.0-or-later WITH x11vnc-openssl-exception

use std::{collections::HashMap, sync::RwLock};

use kb::InMemoryKbStorage;

use crate::models;

use super::{
    error::StorageError,
    items::{
        kb::{GetKbContextKey, KbContextKey, KbItem},
        notus_advisory::NotusAdvisory,
        nvt::{Feed, FeedVersion, FileName, Nvt, Oid},
        result::{ResultContextKeyAll, ResultContextKeySingle, ResultItem},
    },
    Dispatcher, Remover, Retriever, ScanID,
};

pub mod kb;

/// Vts are using a relative file path as a key. This should make includes, script_dependency
/// lookups relative simple.
type Vts = HashMap<String, Nvt>;

/// The results generated by log_, security_, error_message.
type Results = HashMap<ScanID, Vec<ResultItem>>;

type NotusAdvisories = Vec<models::VulnerabilityData>;
/// Is a in-memory dispatcher that behaves like a Storage.
#[derive(Default, Debug)]
pub struct InMemoryStorage {
    // TODO: vts and oids can lead to a deadlock, as they might both be used by the same function.
    vts: RwLock<Vts>,
    oid_lookup: RwLock<HashMap<String, String>>,
    feed_version: RwLock<String>,
    advisories: RwLock<NotusAdvisories>,
    kbs: InMemoryKbStorage,
    results: RwLock<Results>,
}

impl InMemoryStorage {
    /// Creates a new InMemoryStorage.
    pub fn new() -> Self {
        Self {
            ..Default::default()
        }
    }

    /// Stores an already existing Vts structure.
    pub fn set_vts(&self, vts: Vts) -> Result<(), StorageError> {
        let mut vts_internal = self.vts.write()?;
        let mut oid_lookup = self.oid_lookup.write()?;

        for (filename, nvt) in &vts {
            oid_lookup.insert(nvt.oid.clone(), filename.clone());
        }

        *vts_internal = vts;

        Ok(())
    }

    fn cache_notus_advisory(&self, adv: models::VulnerabilityData) -> Result<(), StorageError> {
        let mut data = self.advisories.write()?;
        data.push(adv);
        Ok(())
    }

    fn all_vts(&self) -> Result<Vec<Nvt>, StorageError> {
        let vts = self.vts.read()?;
        let vts = vts.values().cloned();
        let notus = self.advisories.read()?.clone().into_iter().map(Nvt::from);
        Ok(vts.chain(notus).collect())
    }

    /// Removes all stored nasl_vts
    pub fn clean_vts(&self) -> Result<(), StorageError> {
        let mut vts = self.vts.write()?;
        vts.clear();
        let mut version = self.feed_version.write()?;
        *version = String::new();
        Ok(())
    }

    /// Removes all stored nasl_vts
    pub fn clean_advisories(&self) -> Result<(), StorageError> {
        let mut advisories = self.advisories.write()?;
        advisories.clear();
        Ok(())
    }
}

impl Dispatcher<KbContextKey> for InMemoryStorage {
    type Item = KbItem;
    fn dispatch(&self, key: KbContextKey, item: Self::Item) -> Result<(), StorageError> {
        self.kbs.dispatch(key, item)
    }
}

impl Retriever<KbContextKey> for InMemoryStorage {
    type Item = Vec<KbItem>;
    fn retrieve(&self, key: &KbContextKey) -> Result<Option<Self::Item>, StorageError> {
        self.kbs.retrieve(key)
    }
}

impl Retriever<GetKbContextKey> for InMemoryStorage {
    type Item = Vec<(String, Vec<KbItem>)>;
    fn retrieve(&self, key: &GetKbContextKey) -> Result<Option<Self::Item>, StorageError> {
        self.kbs.retrieve(key)
    }
}

impl Remover<KbContextKey> for InMemoryStorage {
    type Item = Vec<KbItem>;
    fn remove(&self, key: &KbContextKey) -> Result<Option<Self::Item>, StorageError> {
        self.kbs.remove(key)
    }
}

impl Dispatcher<()> for InMemoryStorage {
    type Item = NotusAdvisory;
    fn dispatch(&self, _: (), item: Self::Item) -> Result<(), StorageError> {
        self.cache_notus_advisory(item)
    }
}

impl Dispatcher<FileName> for InMemoryStorage {
    type Item = Nvt;
    /// Dispatch a single NVT into the storage with a given Key
    fn dispatch(&self, key: FileName, item: Self::Item) -> Result<(), StorageError> {
        let mut vts = self.vts.write()?;
        let mut oid_lookup = self.oid_lookup.write()?;
        oid_lookup.insert(item.oid.clone(), key.0.clone());
        vts.insert(key.0, item);
        Ok(())
    }
}

impl Dispatcher<FeedVersion> for InMemoryStorage {
    type Item = String;
    /// Dispatch the feed version into the storage
    fn dispatch(&self, _: FeedVersion, item: Self::Item) -> Result<(), StorageError> {
        let mut feed_version = self.feed_version.write()?;
        *feed_version = item;
        Ok(())
    }
}

impl Retriever<FeedVersion> for InMemoryStorage {
    type Item = String;
    /// Retrieve the feed version from the storage
    fn retrieve(&self, _: &FeedVersion) -> Result<Option<Self::Item>, StorageError> {
        Ok(Some(self.feed_version.read()?.clone()))
    }
}

impl Retriever<Feed> for InMemoryStorage {
    type Item = Vec<Nvt>;
    /// Retrieve all NVTs from the storage
    fn retrieve(&self, _: &Feed) -> Result<Option<Self::Item>, StorageError> {
        self.all_vts().map(Some)
    }
}

impl Retriever<FileName> for InMemoryStorage {
    type Item = Nvt;
    fn retrieve(&self, key: &FileName) -> Result<Option<Self::Item>, StorageError> {
        let vts = self.vts.read()?;
        Ok(vts.get(&key.0).cloned())
    }
}

impl Retriever<Oid> for InMemoryStorage {
    type Item = Nvt;
    fn retrieve(&self, key: &Oid) -> Result<Option<Self::Item>, StorageError> {
        let vts = self.vts.read()?;
        let oid_lookup = self.oid_lookup.read()?;
        Ok(oid_lookup
            .get(&key.0)
            .and_then(|filename| vts.get(filename).cloned()))
    }
}

impl Remover<Feed> for InMemoryStorage {
    type Item = ();
    fn remove(&self, _: &Feed) -> Result<Option<Self::Item>, StorageError> {
        self.clean_vts()?;
        Ok(Some(()))
    }
}

impl Dispatcher<ScanID> for InMemoryStorage {
    type Item = ResultItem;
    fn dispatch(&self, key: ScanID, item: Self::Item) -> Result<(), StorageError> {
        let mut results = self.results.write()?;
        if let Some(scan_results) = results.get_mut(&key) {
            scan_results.push(item);
        } else {
            results.insert(key, vec![item]);
        }
        Ok(())
    }
}

impl Retriever<ResultContextKeySingle> for InMemoryStorage {
    type Item = ResultItem;
    fn retrieve(&self, key: &ResultContextKeySingle) -> Result<Option<Self::Item>, StorageError> {
        let results = self.results.read()?;
        if let Some(scan_results) = results.get(&key.0) {
            return Ok(scan_results.get(key.1).cloned());
        }
        Ok(None)
    }
}

impl Retriever<ResultContextKeyAll> for InMemoryStorage {
    type Item = Vec<ResultItem>;
    fn retrieve(&self, key: &ResultContextKeyAll) -> Result<Option<Self::Item>, StorageError> {
        let results = self.results.read()?;

        Ok(results.get(key).cloned())
    }
}

impl Remover<ResultContextKeyAll> for InMemoryStorage {
    type Item = Vec<ResultItem>;
    fn remove(&self, key: &ResultContextKeyAll) -> Result<Option<Self::Item>, StorageError> {
        let mut results = self.results.write()?;
        Ok(results.remove(key))
    }
}

impl Remover<ResultContextKeySingle> for InMemoryStorage {
    type Item = ResultItem;
    fn remove(&self, key: &ResultContextKeySingle) -> Result<Option<ResultItem>, StorageError> {
        let mut results = self.results.write()?;
        if let Some(results) = results.get_mut(&key.0) {
            return Ok(Some(results.remove(key.1)));
        }
        Ok(None)
    }
}

#[cfg(test)]
mod tests {
    use crate::storage::{
        error::StorageError,
        inmemory::InMemoryStorage,
        items::{
            kb::{KbContextKey, KbItem},
            nvt::{FileName, Nvt},
        },
        Dispatcher, Retriever,
    };

    #[test]
    pub fn nvt() -> Result<(), StorageError> {
        let storage = InMemoryStorage::default();
        let key = FileName(String::new());
        let mut nvt = Nvt::default();
        nvt.oid = "moep".to_string();
        storage.dispatch(key.clone(), nvt.clone())?;
        let ret = storage.retrieve(&key).unwrap().unwrap();
        assert_eq!(nvt, ret);
        Ok(())
    }

    #[test]
    pub fn kb() {
        let storage = InMemoryStorage::default();
        let key = KbContextKey::default();
        let value1 = KbItem::String("1".to_string());
        let value2 = KbItem::String("2".to_string());
        storage.dispatch(key.clone(), value1.clone()).unwrap();
        storage.dispatch(key.clone(), value2.clone()).unwrap();
        let ret = storage.retrieve(&key).unwrap().unwrap();
        assert_eq!(ret, vec![value1, value2]);
    }
}
