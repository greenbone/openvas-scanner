// SPDX-FileCopyrightText: 2025 Greenbone AG
//
// SPDX-License-Identifier: GPL-2.0-or-later WITH x11vnc-openssl-exception

use std::{collections::HashMap, sync::RwLock};

use kb::InMemoryKbStorage;

use crate::models;

use super::{
    error::StorageError,
    items::{nvt::Nvt, result::ResultItem},
    ContextStorage, OspStorage, ScanID, SchedulerStorage,
};

pub mod kb;
pub mod notus_advisory;
pub mod nvt;
pub mod result;

/// Vts are using a relative file path as a key. This should make includes, script_dependency
/// lookups relative simple.
type Vts = HashMap<String, Nvt>;

/// The results generated by log_, security_, error_message.
type Results = HashMap<ScanID, Vec<ResultItem>>;

type NotusAdvisories = Vec<models::VulnerabilityData>;
/// Is a in-memory dispatcher that behaves like a Storage.
#[derive(Default, Debug)]
pub struct InMemoryStorage {
    // TODO: vts and oids can lead to a deadlock, as they might both be used by the same function.
    vts: RwLock<Vts>,
    oid_lookup: RwLock<HashMap<String, String>>,
    feed_version: RwLock<String>,
    advisories: RwLock<NotusAdvisories>,
    kbs: InMemoryKbStorage,
    results: RwLock<Results>,
}

impl InMemoryStorage {
    /// Creates a new InMemoryStorage.
    pub fn new() -> Self {
        Self {
            ..Default::default()
        }
    }

    /// Stores an already existing Vts structure.
    pub fn set_vts(&self, vts: Vts) -> Result<(), StorageError> {
        let mut vts_internal = self.vts.write()?;
        let mut oid_lookup = self.oid_lookup.write()?;

        for (filename, nvt) in &vts {
            oid_lookup.insert(nvt.oid.clone(), filename.clone());
        }

        *vts_internal = vts;

        Ok(())
    }

    fn cache_notus_advisory(&self, adv: models::VulnerabilityData) -> Result<(), StorageError> {
        let mut data = self.advisories.write()?;
        data.push(adv);
        Ok(())
    }

    fn all_vts(&self) -> Result<Vec<Nvt>, StorageError> {
        let vts = self.vts.read()?;
        let vts = vts.values().cloned();
        let notus = self.advisories.read()?.clone().into_iter().map(Nvt::from);
        Ok(vts.chain(notus).collect())
    }

    /// Removes all stored nasl_vts
    pub fn clean_vts(&self) -> Result<(), StorageError> {
        let mut vts = self.vts.write()?;
        vts.clear();
        let mut version = self.feed_version.write()?;
        *version = String::new();
        Ok(())
    }

    /// Removes all stored nasl_vts
    pub fn clean_advisories(&self) -> Result<(), StorageError> {
        let mut advisories = self.advisories.write()?;
        advisories.clear();
        Ok(())
    }
}

impl ContextStorage for InMemoryStorage {}

impl SchedulerStorage for InMemoryStorage {}

impl OspStorage for InMemoryStorage {}

#[cfg(test)]
mod tests {
    use crate::storage::{
        dispatch::Dispatcher,
        error::StorageError,
        inmemory::InMemoryStorage,
        items::{
            kb::{KbContextKey, KbItem},
            nvt::{FileName, Nvt},
        },
        Retriever,
    };

    #[test]
    pub fn nvt() -> Result<(), StorageError> {
        let storage = InMemoryStorage::default();
        let key = FileName(String::new());
        let mut nvt = Nvt::default();
        nvt.oid = "moep".to_string();
        storage.dispatch(key.clone(), nvt.clone())?;
        let ret = storage.retrieve(&key).unwrap().unwrap();
        assert_eq!(nvt, ret);
        Ok(())
    }

    #[test]
    pub fn kb() {
        let storage = InMemoryStorage::default();
        let key = KbContextKey::default();
        let value1 = KbItem::String("1".to_string());
        let value2 = KbItem::String("2".to_string());
        storage.dispatch(key.clone(), value1.clone()).unwrap();
        storage.dispatch(key.clone(), value2.clone()).unwrap();
        let ret = storage.retrieve(&key).unwrap().unwrap();
        assert_eq!(ret, vec![value1, value2]);
    }
}
