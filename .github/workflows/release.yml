name: "release"
on: 
  workflow_call:
    inputs:
      new_version:
        required: true
        type: string
      latest_version:
        required: true
        type: string
      release_kind:
        required: true
        type: string
      release_ref:
        required: true
        type: string
      project:
        required: true
        type: string
      repository:
        required: true
        type: string
    secrets:
      token:
        required: true
      name:
        required: true
      email:
        required: true
      gpg_key:
        required: true
      gpg_pass:
        required: true


# This job first determines the target branch of the closed pull request. If the target branch is "main",
# then the latest release tag is used. If no release tag exists, it is set to 0.1.0. If it is a release
# branch (e.g. v22), then the latest tag within that major version is used.
#
# For a patch release, the latest tag is enhanced with 0.0.1, leaving the major and minor versions as
# they are.
#
# For a minor release, the latest tag is enhanced with 0.1.0, and the patch version is set to 0.
#
# For a major release, a branch is created for the latest major release found by tag, and the version
# is enhanced with $latest_tag + 1.0.0, increasing the major version by 1 and setting the minor and
# patch versions to 0.
#
# Major version releases are only valid on the "main" branch.
#
# Once the version is found and enhanced, each CMakeLists file is updated to the new
# version, and a commit is created in the found branch.
jobs:
  release:
    name: release
    runs-on: "self-hosted-generic"
    env:
      RELEASE_KIND: ${{inputs.release_kind}}
      RELEASE_REF: ${{inputs.release_ref}}
      LATEST_VERSION: ${{inputs.latest_version}}
      NEW_VERSION: ${{inputs.new_version}}
      PROJECT: ${{inputs.project}}
      REPOSITORY: ${{inputs.repository}}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.token }}
          fetch-depth: '0'

      - name: Set git credentials
        run: |
          git config --global user.email "${{ secrets.email }}"
          git config --global user.name "${{ secrets.name }}"

      - name: Create working branch for previous major release (${{ env.LATEST_VERSION }})
        if: env.RELEASE_KIND == 'major'
        run: |
          git checkout "v${{ env.LATEST_VERSION }}"
          export BRANCH_NAME=$(echo "${{ env.LATEST_VERSION }}" | sed 's/^\([0-9]*\).*/v\1/')
          git checkout -b "$BRANCH_NAME" && git push origin "$BRANCH_NAME" || true

      # Create binaries
      - uses: ./.github/actions/compile-x86_64
      - uses: ./.github/actions/compile-aarch64
      - run: mv assets/linux/arm64/openvasd assets/openvasd-aarch64-unknown-linux-gnu
      - run: mv assets/linux/amd64/openvasd assets/openvasd-x86_64-unknown-linux-gnu
      - run: mv assets/linux/arm64/scannerctl assets/scannerctl-aarch64-unknown-linux-gnu
      - run: mv assets/linux/amd64/scannerctl assets/scannerctl-x86_64-unknown-linux-gnu
      - run: rm -rf assets/linux
      - run: ls -las assets/
      
      # Create branch of version
      - name: Prepare project version ${{ env.RELEASE_REF }} ${{ env.LATEST_VERSION }} -> ${{ env.NEW_VERSION }}
        run: |
          git checkout "${{ env.RELEASE_REF }}"
          awk '{sub(/appVersion: "[0-9]+\.[0-9]+\.[0-9]+"/,"appVersion: \"${{ env.NEW_VERSION }}\""); print}' charts/openvasd/Chart.yaml | tee /tmp/Chart.yaml
          mv /tmp/Chart.yaml charts/openvasd/Chart.yaml
          if git diff --exit-code --quiet; then
            echo "There are no modified files, skipping."
          else
            git add CMakeLists.txt
            git add charts/openvasd/Chart.yaml
            git commit -m "Automated commit: change version from ${{ env.LATEST_VERSION }} -> ${{ env.NEW_VERSION }}"
            git fetch --all
            git rebase origin/${{ env.RELEASE_REF}}
            git push origin ${{ env.RELEASE_REF }}
          fi

      # Install and run git-cliff to generate changelog
      - name: Install git-cliff
        uses: greenbone/actions/uv@v3
        with:
          install: git-cliff

      - name: Generate changelog with git-cliff
        run: |
          git-cliff -v --strip header -o /tmp/changelog.md --tag "${{ env.NEW_VERSION }}" "${{ env.LATEST_VERSION }}..HEAD"

      # Create GitHub Release with changelog
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.token }}
        run: |
          export nrn="v${{ env.NEW_VERSION }}"
          gh release create "$nrn" -F /tmp/changelog.md

      # Update CHANGELOG.md in the repo after release
      - name: Update CHANGELOG.md
        run: |
          git-cliff -v -o CHANGELOG.md --tag "${{ env.NEW_VERSION }}"
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG.md for v${{ env.NEW_VERSION }}" || echo "No changes to commit"
          git push origin "${{ env.RELEASE_REF }}"

      # Sign assets and upload to release
      - name: Sign ${{ env.PROJECT }}
        run: |
          export nrn="v${{ env.NEW_VERSION }}"
          export filename="$PROJECT-$nrn"
          curl -sfSL --retry 3 --retry-connrefused --retry-delay 2 -o assets/$filename.zip https://github.com/${{ github.repository }}/archive/refs/tags/$nrn.zip
          curl -sfSL --retry 3 --retry-connrefused --retry-delay 2 -o assets/$filename.tar.gz https://github.com/${{ github.repository }}/archive/refs/tags/$nrn.tar.gz
          echo -e "${{ secrets.gpg_key }}" > private.pgp
          echo ${{ secrets.gpg_pass }} | bash .github/sign-assets.sh private.pgp
          rm assets/$filename.zip
          rm assets/$filename.tar.gz
          gh release upload $nrn assets/*